Trading Strategy Builder — Architecture v2
Date: October 26, 2025
1. Overview
A modular EA architecture centered on a Runtime Kernel (control plane) coordinating market data, signal generation, risk, portfolio constraints, execution, and post-fill lifecycle management. The loop always handles exits/modifications first (risk reduction) and entries second (risk addition). Execution/OMS is the single source of truth for the broker state. Position Manager is the single authority for managing open trades. State Manager produces health/metrics and flags; the Kernel applies gates (Spread / Session / Pause / Daily-DD / Error-storm).
Design principles & invariants:
* Single source of truth for orders/positions: Execution/OMS.
* Exit before Entry on every loop (per symbol).
* Pause blocks new entries; Position Manager continues to manage open trades.
* Kill flattens immediately; all actions check Kill before executing.
* Trailing is tighten-only with min-move & throttle; respect freeze/stop-level distances.
* Reverse = close-then-open (NETTING-safe); HEDGING behavior is configurable.
* Event-driven state: State Manager updates immediately on Execution events (not only at loop start).
* Atomic management: Position Manager locks a symbol, executes actions sequentially with reconcile after each, then unlocks.
* Bracket gap protection: defer SL/TP when StopLevel prevents attach; PM re-arms brackets post-fill.
* Unified message vocabulary; single Logger function used by all blocks.
2. Core Runtime Blocks
2.1 Runtime Kernel (aka Orchestrator / Runtime Kernel)
Purpose: Control plane; runs the loop, applies gates, orders steps, coordinates blocks, provides a lightweight logger.
* Responsibilities:
* Loop cadence (tick/bar) and sequencing: Reconcile → Manage Open → New Entries → Record.
* Gate evaluation via State flags: Spread / Session / Pause / Daily-DD / Error-storm.
* Global actions: Pause (block entries, still manage open trades), Kill (flatten now).
* Provide Logger function (single schema/sink).
* Inputs:
* State Manager: HealthFlags (DD%, margin, error counts, connection).
* Execution/OMS: PositionSnapshot, OrderSnapshot, ReconciliationReport.
* Market Data & Platform: Bar/Tick, Spread, SessionStatus.
* Outputs:
* Call order and routing decisions; Pause/Kill control; log events.
* Rules & Guarantees:
* Gates applied twice: (a) before PM — only Kill can block PM; (b) before Entry — all gates enforced.
* Kill is checked by Kernel, PM, and Execution entry points for immediate effect.
* Implementation Notes:
* Logger events: GATE_SKIP, KILL_ON/OFF, PAUSE_TOGGLE, STEP_TIMING, ERROR_SUMMARY.
2.2 Market Data & Platform
Purpose: Normalized market conditions; no broker order/position state.
* Responsibilities:
* Provide Bar/Tick streams, Spread, SessionStatus, and InstrumentInfo (point, tick size, StopLevel, FreezeLevel).
* Expose AccountMode (NETTING | HEDGING) via account properties.
* Inputs:
* MQL5 Porting Layer (adapter).
* Outputs:
* Bar
* Tick
* Spread
* SessionStatus
* InstrumentInfo
* AccountMode
* Rules & Guarantees:
* No direct access to orders/positions (Execution is the sole truth).
2.3 Entry Signal Generator
Purpose: Proposes new entries only.
* Responsibilities:
* Detect setups and emit EntrySignal[] with symbol, direction, confidence, tags.
* Inputs:
* Latest Bar/Tick (optional context from State Manager).
* Outputs:
* EntrySignal[]
* Rules & Guarantees:
* No sizing/portfolio/broker I/O; stateless across ticks except its own internal buffers if needed.
2.4 Exit Signal Generator
Purpose: Advises exits/reversals; Position Manager decides & acts.
* Responsibilities:
* Evaluate exit/reverse logic using price and position context.
* Inputs:
* Bars/Ticks
* Position context (side, qty, avg price)
* Outputs:
* ExitAdvice
* ReverseAdvice
* Rules & Guarantees:
* No direct broker actions; advisory only.
2.5 Risk Management
Purpose: Convert EntrySignal[] into executable Order Intent[].
* Responsibilities:
* Size positions; compute initial SL/TP; choose order type; set Intent TTL; tag intents.
* Validate min/max lot, step sizes, minimum risk/reward; drop malformed intents.
* Inputs:
* EntrySignal[]
* InstrumentInfo (steps/lot/StopLevel)
* Optional State context
* Outputs:
* OrderIntent[]
* Rules & Guarantees:
* No portfolio enforcement; no trailing; no broker I/O.
2.6 Portfolio
Purpose: Approve, prune, and prioritize intents vs exposure/capacity.
* Responsibilities:
* MVP: one-position-per-symbol; global MaxConcurrentPositions.
* Select best intent by confidence if multiple fire simultaneously when flat.
* Inputs:
* OrderIntent[]
* Current exposure snapshot (from Execution/State).
* Outputs:
* ApprovedIntent[]
* Rules & Guarantees:
* No sizing; no broker I/O.
* Implementation Notes:
* Log PORT_APPROVE with selected/pruned counts.
2.7 Execution / OMS
Purpose: The only component that talks to the broker; reconciles state.
* Responsibilities:
* Place/modify/cancel orders; attach brackets (two-step when StopLevel prevents attach).
* Reconcile orders & positions; emit snapshots and real-time events.
* Retry on transient errors; classify fatal errors; final pre-send spread check.
* Inputs:
* ApprovedIntent[]
* PM requests: Close, Reverse, ModifySL, CancelPending, RearmBrackets.
* Outputs:
* OrderEvent
* FillEvent
* PositionSnapshot
* OrderSnapshot
* ReconciliationReport
* Rules & Guarantees:
* All public methods guard on Kernel Kill flag; return REJECTED_KILL_ACTIVE when active.
* Single source of truth for positions/orders; State Manager consumes events/snapshots.
* Implementation Notes:
* Reconcile(): compare broker vs cache; adopt orphaned, purge ghosts, accept external SL/TP changes; report breakCount.
* PlaceEntryWithBracket(): StopLevel check → place → poll fill ≤ 2s → attach SL/TP if missing; return bracket_status OK|DEFERRED|FAILED.
* Retry taxonomy: retry ≤3 with 200ms backoff on REQUOTE/PRICE_OFF/TIMEOUT; fatal abort on INVALID_STOPS/INVALID_VOLUME/NO_MONEY; accept PARTIAL_FILL.
* Health probe: measure SymbolInfoTick latency; if >2000ms, mark State.Health=DEGRADED; log HEALTH_LATENCY_WARN.
2.8 Position Manager (sole owner of exits & modifications)
Purpose: Manage everything about open trades: exits, reversals, trailing, BE, time exits, housekeeping.
* Responsibilities:
* Precedence: Forced (kill/session end/error-storm) → Strategy exit/reverse → Trail/BE/Time → Housekeeping (TTL cancel, bracket re-arm).
* Build action queue atomically; execute sequentially with reconcile after each; lock symbol during management.
* Guardrails: tighten-only, MinMovePts, throttle (ModifyThrottleSec & MaxModPerMin), freeze/stop-level safety, spread-aware.
* Inputs:
* PositionSnapshot (Execution)
* Bars/Ticks/ATR/Spread (Market Data & Platform)
* ExitAdvice / ReverseAdvice (Exit Signal Generator)
* HealthFlags (State Manager)
* Outputs:
* Requests to Execution: Close, Reverse (close→open), ModifySL, CancelPending, RearmBrackets
2.8.1 Exit Executor (sub-block of Position Manager)
Purpose: Execute all exit and reverse actions, including forced exits and strategy-advised exits/reversals.
* Responsibilities:
* Handle forced exits immediately (Kill, end-of-session flatten, error-storm).
* Process strategy ExitAdvice/ReverseAdvice with precedence over trailing.
* Reverse semantics: NETTING = close then open; HEDGING = configurable allowHedging else close then open.
* Ensure idempotency (avoid duplicate closes); wait for confirmation events; reconcile after each action.
* Check Kill before each action; abort with REJECTED_KILL_ACTIVE if active.
* Inputs:
* PositionSnapshot (Execution)
* ExitAdvice / ReverseAdvice (Exit SG)
* HealthFlags (State Manager)
* Spread/SessionStatus (Market)
* Outputs:
* Execution requests: ClosePosition, ReversePosition (close→open), CancelPending (when replacing orders)
* Rules & Guarantees:
* Forced exits supersede all other actions.
* Reverse actions are serialized: close must confirm before open in NETTING mode.
* Events logged: PM_EXIT_FORCED, PM_EXIT_STRATEGY, PM_REVERSE.
2.8.2 Trade Lifecycle Manager (sub-block of Position Manager)
Purpose: Manage trailing stop, break-even, time-based exits, bracket re-arming, and pending TTL housekeeping.
* Responsibilities:
* Trailing modes: BE hop (at +R with buffer), ATR/Chandelier, Fixed-step, Percent, Structure (later).
* Tighten-only rule; compute candidate SL and apply MinMovePts & throttle (ModifyThrottleSec, MaxModPerMin).
* Safety checks: freeze/stop-level distance, spread-aware limits, instrument step sizes.
* RearmBrackets: attach missing SL/TP after fill; retry with escalation after 3 failures (Emergency Exit or Emergency SL).
* CancelStale: enforce TTL for pending orders; request CancelPending when expired.
* Update per-position lastModifyTime and keep SL changes idempotent.
* Inputs:
* PositionSnapshot (Execution)
* Bars/Ticks/ATR/Spread & InstrumentInfo (Market & Platform)
* Config: Trail mode parameters, MinMovePts, ModifyThrottleSec, MaxModPerMin, Pending TTL
* Outputs:
* Execution requests: ModifySL, RearmBrackets, CancelPending
* Logs: PM_TRAIL_MOVE, PM_TRAIL_SKIP (Throttle|MinMove|Freeze|Spread), PM_TTL_CANCEL, PM_REARM_BRACKETS, PM_EMERGENCY_*
2.9 State Manager
Purpose: Central cache of metrics and health flags; never a second truth.
* Responsibilities:
* Maintain equity/balance/margin/DD%; connection & error counters; derive HealthFlags (pause/kill suggestions, error-storm).
* Ingest Execution real-time events: OnOrderPlaced, OnFill, OnPositionClosed, OnSLTPModified, OnCancel.
* Provide immediate updates to Kernel/PM; still perform full ingest at start-of-loop Reconcile.
* Inputs:
* Execution snapshots & events
* Account info via adapter
* Outputs:
* HealthFlags, summarized account/position metrics
* Rules & Guarantees:
* Never contradict Execution; if mismatch detected, rely on next Reconcile().
3. Verticals (Cross-cutting)
3.1 Porting Layer (MQL5 Adapter)
Purpose: Uniform, testable wrapper over MQL5 APIs; hides platform specifics.
* Responsibilities:
* CopyRates, symbol normalization, CTrade wrappers, Stop/Freeze levels, normalized error codes, account mode fetch.
* Outputs:
* Adapter calls used by Market, Execution, State
* Rules & Guarantees:
* No business logic inside the adapter.
3.2 Logger (Kernel sub-function, callable by all)
Purpose: Single structured log function; consistent schema and sink.
* Responsibilities:
* Emit concise breadcrumbs with runId + key k=v pairs.
* Inputs:
* Events from all blocks
* Outputs:
* CSV/terminal lines suitable for debugging and post-run analysis
* Implementation Notes:
* Key events: GATE_SKIP, ENTRY_SIGNAL, EXIT_ADVICE, INTENT, APPROVED, ORDER_SUBMIT/REJECT, FILL, POSITION_UPDATE, PM_TRAIL_MOVE/SKIP, PM_EXIT/REVERSE, BRACKET_*, RECON_*, HEALTH_LATENCY_WARN, KILL, PAUSE_TOGGLE.
4. Unified Runtime Workflow (per symbol, each tick/bar)
1. Reconcile (Execution/OMS): compare broker vs cache; adopt/purge/accept SLTP changes; emit PositionSnapshot/OrderSnapshot + ReconciliationReport. State Manager ingests and updates HealthFlags immediately.
2. Gates (Runtime Kernel): Kill → PM closes now via Execution → Reconcile → End; Pause/Spread/Session/Data fail → block new entries, still manage open trades.
3. Manage Open Trades (Position Manager): lock symbol; gather PositionSnapshot, Market data, ExitAdvice, HealthFlags; build action queue (Forced → Strategy exit/reverse → Trail/BE/Time → Housekeeping). For each action: check Kill, execute via Execution, State updates via events, Reconcile; unlock.
4. New Entries (if policy allows; e.g., flat): Entry SG → Risk → Portfolio → Execution (final spread check; two-step bracket if needed). Fills via Execution; PM adopts on next loop.
5. Record & Log: State Manager refreshes metrics; Logger records concise events.
5. Message Vocabulary
* Market & Platform → Bar, Tick, Spread, SessionStatus, InstrumentInfo, AccountMode
* Execution/OMS → OrderEvent, FillEvent, PositionSnapshot, OrderSnapshot, ReconciliationReport
* State Manager → HealthFlags (DD%, margin headroom, error-storm, connection)
* Exit SG → PM → ExitAdvice, ReverseAdvice
* Entry SG → Risk → EntrySignal[] → OrderIntent[]
* Portfolio → Execution → ApprovedIntent[]
* PM → Execution → Close, Reverse (close→open), ModifySL, CancelPending, RearmBrackets
6. Guardrails & Test Scenarios
Guardrails (enforced across blocks):
* Execution guards Kill at every entry point; PM checks Kill before each action.
* Trailing modify throttle (ModifyThrottleSec, MaxModPerMin) and MinMovePts to avoid spam/freeze rejections.
* Bracket gap protection via PlaceEntryWithBracket + PM.RearmBrackets with escalation after 3 failures.
* Order TTL enforced by PM housekeeping for pending orders.
* Retry taxonomy in Execution: retryable (≤3, 200ms) vs fatal abort; accept partial fills.
Validation tests (run in Tester/live sandbox):
* Manual close via mobile: Reconcile adopts/purges; PM avoids trailing ghosts.
* StopLevel prevents attach: bracket deferred → PM re-arms → escalate on repeated failure.
* Reverse in NETTING vs HEDGING: verify configured behavior.
* Kill during trailing: actions rejected immediately; flatten succeeds; logs show sequence.
* Pending TTL expiry: PM cancels; logs PM_TTL_CANCEL.
* Throttle: frequent SL updates respected; PM_TRAIL_SKIP (Throttle/MinMove/Freeze/Spread) logged.
* Retry handling: REQUOTE/PRICE_OFF/TIMEOUT retried then aborted; fatal errors abort immediately.
* Portfolio pass-through: when flat, select top-confidence signal; when not flat, block entries.